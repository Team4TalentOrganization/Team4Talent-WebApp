@using System.Text;
@inject HttpClient httpClient
@inject IJSRuntime JS
@if (!quizEnded)
{
    <Animation Effect="Effect.ZoomIn" Speed="@Speed.Fast">
        <div class="container bg-custom-color" style="width: 70%; height: 350px; position: relative; overflow: hidden; border-radius: 15px;">
            <div class="mt-4" style="width: 48%; height:50%; float:left;">

                    <div id="topLeftCard" class="card @CardClasses[0]" @onmouseover="() => MouseOver(0)" @onmouseout="() => MouseOut(0)" @onclick="() => CardClicked(0)">
                        <div class="card-body text-center d-flex align-items-center">
                        <p class="m-auto">@GetOptionsForCurrentQuestion()[0]</p>
                    </div>
                </div>
                
          
                    <div id="topRightCard" class="card @CardClasses[1]" @onmouseover="() => MouseOver(1)" @onmouseout="() => MouseOut(1)" @onclick="() => CardClicked(1)">
                    <div class="card-body text-center d-flex align-items-center">
                        <p class="m-auto">@GetOptionsForCurrentQuestion()[1]</p>
                    </div>
                </div>
                
            </div>
            <div class="mt-4" style="width: 48%; height:50%; float:right;">
          
                    <div id="bottomLeftCard" class="card @CardClasses[2]" @onmouseover="() => MouseOver(2)" @onmouseout="() => MouseOut(2)" @onclick="() => CardClicked(2)">
                    <div class="card-body text-center d-flex align-items-center">
                        <p class="m-auto">@GetOptionsForCurrentQuestion()[2]</p>
                    </div>
                </div>
               
             
                    <div id="bottomRightCard" class="card @CardClasses[3]" @onmouseover="() => MouseOver(3)" @onmouseout="() => MouseOut(3)" @onclick="() => CardClicked(3)">
                    <div class="card-body text-center d-flex align-items-center">
                        <p class="m-auto">@GetOptionsForCurrentQuestion()[3]</p>
                    </div>
                </div>
                
            </div>
            <div style="clear: both;"></div>
            <p class="text-white text-center" style="position: absolute; bottom: 17%; left: 50%; transform: translateX(-50%); width:85%">@GetCurrentQuestionPhrase()</p>
            @if (currentQuestion > 0)
            {
                <button @onclick="() => previousQuestionClicked()" id="previousButton" type="button" class="btn btn-light btn-circle btn-lg rounded-circle mb-3" style="position: absolute; bottom: 0;">
                    <span style="font-size: 20px;">&lt;</span>
                </button>
            }
        </div>
    </Animation>
    @if (currentQuestion < questions.Count - 2)
    {
        <button @onclick="() => nextQuestionClicked()" disabled="@(!AreAnyCardsSelected())" type="button" class="nextButton btn btn-primary rounded-btn">VOLGENDE VRAAG</button>
    }
    else
    {
        <button @onclick="() => endQuizClicked()" disabled="@(!AreAnyCardsSelected())" type="button" class="nextButton btn btn-primary rounded-btn">EINDE QUIZ</button>
    }
}
else
{
    <TinderQuestionCard></TinderQuestionCard>
}


@code {
    bool quizEnded = false;
    int currentQuestion = 0;
    private List<Question> questions = new List<Question>();
    private List<int> domainAnswers = new List<int>();
    bool subDomainsAreSet = false;

    string[] CardClasses = new string[4] { "card text-black h-50 mb-3", "card text-black h-50 mb-3", "card text-black h-50 mb-3", "card text-black h-50 mb-3" };

    async Task MouseOver(int cardNumber)
    {
        await SetCardClass(cardNumber, CardClasses[cardNumber].Contains("bg-orange-color-click") ? "card text-white bg-orange-color-click h-50 mb-3" : "card text-white bg-orange-color h-50 mb-3");
    }

    async Task MouseOut(int cardNumber)
    {
        await SetCardClass(cardNumber, CardClasses[cardNumber].Contains("bg-orange-color-click") ? "card text-white bg-orange-color-click h-50 mb-3" : "card text-black h-50 mb-3");
    }

    async Task SetCardClass(int cardNumber, string cssClass)
    {
        CardClasses[cardNumber] = cssClass;
    }

    void CardClicked(int cardNumber)
    {
        // Check if the option is not empty before toggling
        if (!IsOptionValueEmpty(GetOptionsForCurrentQuestion()[cardNumber]))
        {
            // Toggle between two states
            if (CardClasses[cardNumber].Contains("bg-orange-color-click"))
            {
                CardClasses[cardNumber] = "card text-black h-50 mb-3";
            }
            else
            {
                CardClasses[cardNumber] = "card text-white bg-orange-color-click h-50 mb-3";
            }
        }
    }

    private List<string> GetOptionsForCurrentQuestion()
    {
        return questions[currentQuestion].Options.Select(option => option.Content).ToList();
    }
    private List<int> GetOptionIdForCurrentQuestion()
    {
        return questions[currentQuestion].Options.Select(option => option.OptionId).ToList();
    }

    public string GetCurrentQuestionPhrase()
    {
        return questions.ElementAt(currentQuestion).Phrase;
    }

    public async void nextQuestionClicked()
    {
        if (GetCurrentQuestionPhrase() == "In welk domein heb je interesse?")
        {
            for(int i = 0; i < 4; i++)
            {
                if (CardClasses[i] == "card text-white bg-orange-color-click h-50 mb-3")
                {
                    domainAnswers.Add(GetOptionIdForCurrentQuestion()[i]);
                }
            }
        }
        currentQuestion++;
        ResetCardClasses();
        if (GetCurrentQuestionPhrase() == "In welk subdomein heb je interesse?" && !subDomainsAreSet)
        {
            StringBuilder endpointBuilder = new StringBuilder("https://localhost:7109/api/Quiz/subdomains?");
            List<Option> subDomains = new List<Option>();
            bool isFirstDomain = true;

            foreach (int domainId in domainAnswers)
            {
                if (!isFirstDomain)
                {
                    endpointBuilder.Append("&");
                }

                endpointBuilder.Append($"domainId={domainId}");

                isFirstDomain = false;
            }

            string endpointString = endpointBuilder.ToString();

            subDomains = await httpClient.GetFromJsonAsync<List<Option>>(endpointString);
            questions[currentQuestion].Options = subDomains;
            await JS.InvokeVoidAsync("console.log", questions[currentQuestion].Options);
            subDomainsAreSet = true;
        }
        await JS.InvokeVoidAsync("console.log", questions);
    }

    public void previousQuestionClicked()
    {
        if (currentQuestion > 0)
        {
            currentQuestion--;
            ResetCardClasses();
        }
    }

    private void ResetCardClasses()
    {
        for (int i = 0; i < CardClasses.Length; i++)
        {
            CardClasses[i] = "card text-black h-50 mb-3";
        }
    }

    public void endQuizClicked() {
        quizEnded = true;
    }

    public bool AreAnyCardsSelected()
    {
        return CardClasses.Any(cc => cc.Contains("bg-orange-color-click"));
    }

    public bool IsOptionValueEmpty(string value)
    {
        if (value == null)
        {
            return true;
        }
        return false;
    }

    protected override async Task OnInitializedAsync()
    {
        questions = await httpClient.GetFromJsonAsync<List<Question>>("https://localhost:7109/api/Quiz/standardquizquestions");

        // Iterate through the questions
        for (int i = 0; i < questions.Count; i++)
        {
            // Check if the current question has 3 or fewer options
            if (questions[i].Options.Count <= 3)
            {
                // Calculate the number of empty options to add
                int emptyOptionsToAdd = 4 - questions[i].Options.Count;

                // Add new empty options to the current question
                for (int j = 0; j < emptyOptionsToAdd; j++)
                {
                    questions[i].Options.Add(new Option()); // You can change this to the default value for new options
                }
            }
            else if (questions[i].Options.Count > 4)
            {
                // Create a new question with the remaining options
                var remainingOptions = questions[i].Options.Skip(4).ToList();
                var newQuestion = new Question
                    {
                        Options = remainingOptions,
                        QuestionId = questions[i].QuestionId, // Use the same QuestionId if needed
                        Phrase = questions[i].Phrase
                    };

                // Insert the new question right after the current question
                questions.Insert(i + 1, newQuestion);

                // Trim the current question's options to the first 4
                questions[i].Options = questions[i].Options.Take(4).ToList();
            }
        }
    }


    private class Question
    {
        public List<Option> Options { get; set; }
        public int QuestionId { get; set; }
        public string Phrase { get; set; }
    }

    private class Option
    {
        public string Content { get; set; }
        public int OptionRelation { get; set; }
        public int QuestionId { get; set; }
        public int OptionId { get; set; }
    }
}
